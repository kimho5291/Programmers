

// 풀이
// 에라토스테네스의 체 알고리즘 -> 위키백과 : https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4
// 간단한 정리 : 자신이 소수임을 알면 주어진 수 까지 자신을 곱해가면서 수를 제외한다.
// ex) 5 => 배열 선언 및 값 넣기 [2, 3, 4, 5] => 2는 소수, 2의 배수는 전부 0으로 처리 => [2,3,0,5] => 따라서 소수는 2, 3, 5 이다.

// 소수 : 1과 자신이외의 수로는 나눠지지 않는 1보다 큰 양의 정수
// 제곱근 까지 나누는 이유 : 어떤 숫자의 약수는 대칭적으로 이뤄지기 때문이다.
// ex) 100의 약수 : 1, 2, 4, 5, 10, 20, 25, 50, 100
// 2 * 50 = 100
// 4 * 25 = 100
// 5 * 20 = 100
// 10 * 10 = 100 => 10 = 100의 제곱근
// 20 * 5 = 100 // 여기부터 불필요 위에서 이미 다 알아냈음 !
// 25 * 4 = 100
// 50 * 2 = 100
// 따라서 10 x 10 이전의 소수로만 나눗셈을 수행한 후 나누어 떨어지지 않으면 소수라고 판단할 수 있다.


// ⓐ => 주어진 수까지 값이 들어간 배열 선언 및 값 넣어주기
// ⓑ => 반복문은 n의 제곱근 까지 반복(Math.sqrt 활용)
// ⓒ => temp[i-2]인 이유는 temp[0] = 2 부터 시작하기때문
//    => if(temp[i-2]) => temp[i-2] != 0 이라는 뜻과 같다.
// ⓓ => j = i*i인 이유는 i가 소수면 i의 배수는 전부 약수이기 때문이다.
//    => 그래서 i의 배수 전부 0으로 처리
// ⓔ => 정답은 소수의 개수임으로 arrary.filter를 통해 소수인 애들만 뽑아온 이후 length로 개수를 알수 있다.


function solution(n) {
    let temp = [];
    
    for(let i=2; i<=n;i++){ // ⓐ
        temp.push(i); 
    }
    
    for(let i=2; i <= Math.sqrt(n); i++){ // ⓑ
        if(temp[i-2]) // ⓒ
            for(let j=i*i; j<=n; j+= i) temp[j-2] = 0; // ⓓ
    }
    
    var answer = temp.filter(e => e != 0).length; // ⓔ
    return answer;
}
