
Union Find
합집합 찾기
말그대로 자신의 그룹에 있는지 확인하는 알고리즘

일단 주어진 변수로 트리를 완성하는게 최우선 적이다.

만드는 방법
array를 사용하여서 자신(index)에 부모는 누구인지 기재하는것이다.

ex) 3개의 node가 있을 때 두번째 노드가 첫번째 노드의 자식일 경우
array[0] = 0 => 부모가 없을 시 자기자신 
array[1] = 0 => 첫번째 노드가 부모이기 때문에 0
array[2] = 2 => 부모가 없음으로 자기자신

union -> find 2개를 구현해야 union find 이다.




알고리즘 문제를 풀때 도움이되는 개선방법
1. 경로 압축(path compression)
생성된 트리를 전부 순회하기 어려운 경우 최상위 부모에 모두 쏠아버리는 방법이다.
ex) 5개의 node가 일직선으로 연결된 경우
array[0] = 0
array[1] = 0
array[2] = 1
array[3] = 2
array[4] = 3

부모를 최상위 부모로 변경한다.
array[0] = 0
array[1] = 0
array[2] = 0
array[3] = 0
array[4] = 0

2. 유니온 바이 랭크 (Union by rank)
만들어진 그룹 (trees) 중 작은 트리를 큰 트리에 붙힌다. 
풀이에 따라서 붙히지 않아도 됨

rank와 size는 동의어 이며
나를 포함해 내 밑에 있는 node의 수를 의미한다.
이를 통해 트리를 구성할 수 있다.
size가 크면 부모, 같으면 형제, 작으면 자식으로 판단 가능.


lv3 네트워크
lv2 전력망을 둘로 나누기