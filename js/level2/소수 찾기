
var split_arr = null;

function solution(numbers) {
    var answer = 0;
    split_arr = numbers.split("");
    console.log(split_arr)
    
    let arr2 = [];
    for(let i=0; i<split_arr.length; i++){ // i는 자리수
        let temp = split_arr.map((e, index) => {
            console.log("e : "+e+" || index : "+index);
            //for(let j=0; j<)
            
            return e;
        });
        arr2.push(temp);
    }
    console.log(arr2)
    
    
    return answer;
}


// 알고리즘 구상
/*
ex) 1 2 3 4
1자리 수
[1] [2] [3] [4]
2자리수
[1] 2 3 4 [2] 1 3 4 [3] 1 2 4 [4] 1 2 3
3자리수
[1] (2) 3 4 (3) 2 4 (4) 2 3
[2] (1) 3 4 (3) 1 4 (4) 1 3
[3] (1) 2 4 (2) 1 4 (4) 1 2
[4] (1) 2 3 (2) 1 3 (3) 1 2
4자리수
[1] 234

위 처럼 반복을 자리 수 만큼
해당 자리수에서 글자수만 큼 반복
재귀를 사용할 함수 생성 -> (num, arr, count)  -> num -> 위와 같이 기준이 되는 숫자
                                            -> arr -> 기준으로 선정되지 않은 숫자
                                            -> count -> 남은 자리수
재귀를 통해 나온 숫자에 자신(기준)의 숫자를 더해 요소 추가
ex) 
3자리 1234

1 234 2
    => 2 34 1
        => 3 4 0 
        => return 3
    => add("2"+"3");
        => 4 3 0
        =>return 4
    => add ("2"+"4");
    => 3 42 1
        => 4 2 0
        => return 4
    => add("3"+"4");
        => 2 4 0
        => return 2
    => add("3"+"2");
    => 4 23 1
        => 2 3 0
        => return 2
    => add("4"+"2");
        => 3 2 0
        => return 3
    => add("4"+"3");
    => return ["23", "23", "34", "32", "42", "43"];
add("1"+"23");
add("1"+"24");
add("1"+"34");
add("1"+"32");
add("1"+"42");
add("1"+"43");

위와 같은 느낌으로 도는 것!! 재귀 가능
*/